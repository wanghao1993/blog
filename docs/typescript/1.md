---
title: 基础-变量声明
date: 2022-06-17
tags:
 - TS
categories: 
 - TypeScript
---

## 为什么要使用TypeScript

JS是弱类型的语言，经常在开发的过程中会看到很多类型导致的错误。例如

`Cannot read property, null is not object`

![ts](https://blog-1302483222.cos.ap-shanghai.myqcloud.com/ts-1.png)
但是Ts也是有缺点的，例如在大型项目中会增加编译负担，热更新会变得缓慢。

## 数据类型及类型声明

TS是JS的超集，所以包含了js的所有数据类型和语法，同时还有自己的类型和语法。

例如：`number、boolean、string、object、bigint、symbol、undefined、null `还有就是它们的包装类型 `Number、Boolean、String、Object、Symbol`。

这些很容易理解，给 JS 添加静态类型，总没有必要重新造一套基础类型吧，直接复用 JS 的基础类型就行。

复合类型方面，JS 有 class、Array，这些 TypeScript 类型系统也都支持，但是又多加了三种类型：元组（Tuple）、接口（Interface）、枚举（Enum）


```ts
// boolean 类型
let bool: boolean = true
// number 类型
let num: number = 123
// string 类型
let str: string = 'abc'
// 数组

// 两种声明方式
let arr1: number[] = [1, 2, 3]
let arr2: Array<number> = [1, 2, 3, 4]

// 这样子会报错哦
let arr3: Array<number> = [1, 2, 3, '4'] 
```

**元组** 类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。
```ts
let tuple: [number, string] = [0, '1']
// 可以push等操作，但是通过下标获取的时候会有错误提示，索引不存在
tuple.push(2)
console.log(tuple)
// error Tuple type '[number, string]' of length '2' has no element at index '2'
tuple[2] 
// 也能通过遍历得到结果
tuple.forEach((item) => {
    console.log(item)
})
```

**接口** (Interface）可以描述函数、对象、构造器的结构

描述对象

```ts
interface UserInfo {
    name: string;
    id: string
}
const user1: UserInfo = {
    name: 'xiugougou1',
    id: '222'
}
// 如果类型不匹配的话，会提示错误。

```
![interface](https://blog-1302483222.cos.ap-shanghai.myqcloud.com/ts-2.png)

```ts
class UserDetailInfo implements UserInfo {
    name: string;
    id: string;
    age: number
}

const xiugougou2: UserDetailInfo = {
    name: 'xiugougou2',
    id: '2',
    age: 2
}
```

假如我们用一个对象来描述一些未知的属性，或者可选属性怎么办？我们可以通过可选符号 `?`来表示，例如：

```ts
interface UserInfo {
    name: string;
    id: string;
    city?: string; // city 为可选属性
}
// 有时候我们希望一个接口允许有任意的属性，可以使用如下方式：

interface UserInfo {
    name: string;
    id: string;
    city?: string; // city 为可选属性
    [propName: string]: any
}
```

此外还有只读属性等等，可以用readonly来表示，例如：


```ts
interface UserInfo {
    readonly name: string;
    id: string;
    city?: string; // city 为可选属性
}

const obj: Person = {
    name: 'guang',
    city: 18,
    id: '22'
}
// 此时就会提示错误，
// Cannot assign to 'name' because it is a read-only property.
obj.name = 'xxx'
```

描述函数

```ts
interface FuncA {
    (name: string ):string
}

const hello: FuncA = (name) => `${name}`

```

描述构造器


```ts
interface UserInfo {
    name: string;
    id: string;
}

interface UserConstructor {
    new (name: string, id: number): UserInfo;
}

function createUser(ctor: UserConstructor):IPerson {
    return new ctor('xiugougou3', 18);
}

```

**枚举类型** 是一系列数据的集合

```ts


// 数字枚举
enum Role {
    Reporter = 1,
    Developer,
    Maintainer,
    Owner,
    Guest
}
// console.log(Role.Reporter)
// console.log(Role)

// 1: "Reporter"
// 2: "Developer"
// 3: "Maintainer"
// 4: "Owner"
// 5: "Guest"
// Developer: 2
// Guest: 5
// Maintainer: 3
// Owner: 4
// Reporter: 1

// 字符串枚举
enum Message {
    Success = '恭喜你，成功了',
    Fail = '抱歉，失败了'
}

// {
// Fail: "抱歉，失败了"
// Success: "恭喜你，成功了"
// }

// 异构枚举
enum Answer {
    N,
    Y = 'Yes'
}
// 解析出来是这样的
// 0: "N"
// N: 0
// Y: "Yes"


// 枚举成员
// Role.Reporter = 0
enum Char {
    // const member
    a,
    b = Char.a,
    c = 1 + 3,
    // computed member
    d = Math.random(),
    e = '123'.length,
    f = 4
}

// 0: "b"
// 0.8325154981306795: "d"
// 3: "e"
// 4: "f"
// a: 0
// b: 0
// c: 4
// d: 0.8325154981306795
// e: 3
// f: 4

// 常量枚举
const enum Month {
    Jan,
    Feb,
    Mar,
    Apr = Month.Mar + 1,
    // May = () => 5
}
let month = [Month.Jan, Month.Feb, Month.Mar]

// 枚举类型
enum E { a, b }
enum F { a = 0, b = 1 }
enum G { a = 'apple', b = 'banana' }

let e: E = 3
let f: F = 3
// console.log(e === f) false 

let e1: E.a = 3
let e2: E.b = 3
let e3: E.a = 3
// console.log(e1 === e2) false
// console.log(e1 === e3) true

let g1: G = G.a
let g2: G.a = G.a


```

还有一些symbol等等就不一个个写了，还有字面量类型，看看文档就知道了。

除此以外还有一些四个特殊的类型，`unknown, never, void, any`

- never 代表不可达，比如函数抛异常的时候，返回值就是 never。
- void 代表空，可以是 undefined 或 never。
- any 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。
- unknown 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。

## 泛型

假如我们一个方法可以接受任何类型的参数，怎么办？那我是不是要写很多个方法，或者使用函数的重载来解决，或者直接any。实际上我们可以通过 泛型 来解决这个问题，来支持未来的扩展，例如：

```ts

// 接口

interface Swap <T, U>{
  (param: [T, U]): [U, T]
}
// 泛型变量

const swap: Swap[number, string] = <T, U>(tuple: [T, U]): [U, T] => {
  return [tuple[1], tuple[0]]
}


// 泛型类
class SomeClass<T> {
    private arr: T[] = []
    public push(item: T) {
        this.arr.push(item)
    }
}

```
## 交叉类型和联合类型

联合类型，有时候单个类型无法满足我们的需求，这时候就需要使用联合类型。

```ts
// 这时候uniType既可以是string类型也可以是数组

const uniType: string|string[] = []

uniType = '1'

uniType = ['1']
```

交叉类型